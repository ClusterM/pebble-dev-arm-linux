diff --git a/include/ui/console.h b/include/ui/console.h
index c249db4f7..7574d7e6d 100644
--- a/include/ui/console.h
+++ b/include/ui/console.h
@@ -437,6 +437,7 @@ int index_from_key(const char *key);
 
 /* gtk.c */
 void early_gtk_display_init(int opengl);
-void gtk_display_init(DisplayState *ds, bool full_screen, bool grab_on_hover);
+void gtk_display_init(DisplayState *ds, bool full_screen, bool grab_on_hover,
+                      bool detach_display, bool zoom_to_fit, bool no_grab);
 
 #endif
diff --git a/ui/gtk.c b/ui/gtk.c
index b95336de3..cf9c002ff 100644
--- a/ui/gtk.c
+++ b/ui/gtk.c
@@ -172,6 +172,7 @@ struct GtkDisplayState {
     bool modifier_pressed[ARRAY_SIZE(modifier_keycode)];
     bool has_evdev;
     bool ignore_keys;
+    bool no_grab;
 };
 
 static void gd_grab_pointer(VirtualConsole *vc, const char *reason);
@@ -932,7 +933,7 @@ static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,
 
     /* implicitly grab the input at the first click in the relative mode */
     if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&
-        !qemu_input_is_absolute() && s->ptr_owner != vc) {
+        !qemu_input_is_absolute() && s->ptr_owner != vc && !s->no_grab) {
         if (!vc->window) {
             gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),
                                            TRUE);
@@ -1157,6 +1158,12 @@ static gboolean gd_tab_window_close(GtkWidget *widget, GdkEvent *event,
     VirtualConsole *vc = opaque;
     GtkDisplayState *s = vc->s;
 
+    /* If main window is hidden (detached mode), quit the application */
+    if (!gtk_widget_get_visible(s->window)) {
+        qmp_quit(NULL);
+        return TRUE;
+    }
+
     gtk_widget_set_sensitive(vc->menu_item, true);
     gd_widget_reparent(vc->window, s->notebook, vc->tab_item);
     gtk_notebook_set_tab_label_text(GTK_NOTEBOOK(s->notebook),
@@ -1379,6 +1386,9 @@ static void gd_grab_pointer(VirtualConsole *vc, const char *reason)
 #ifdef NO_MOUSE
     return;
 #endif
+    if (vc->s->no_grab) {
+        return;
+    }
     GdkDisplay *display = gtk_widget_get_display(vc->gfx.drawing_area);
 
     if (vc->s->ptr_owner) {
@@ -2028,12 +2038,46 @@ static void gd_set_keycode_type(GtkDisplayState *s)
 
 static gboolean gtkinit;
 
-void gtk_display_init(DisplayState *ds, bool full_screen, bool grab_on_hover)
+static void gd_detach_vc(GtkDisplayState *s, VirtualConsole *vc)
+{
+    if (vc->type == GD_VC_GFX &&
+        qemu_console_is_graphic(vc->gfx.dcl.con)) {
+        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),
+                                       FALSE);
+    }
+    if (!vc->window) {
+        gtk_widget_set_sensitive(vc->menu_item, false);
+        vc->window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+        gd_widget_reparent(s->notebook, vc->window, vc->tab_item);
+
+        g_signal_connect(vc->window, "delete-event",
+                         G_CALLBACK(gd_tab_window_close), vc);
+        gtk_widget_show_all(vc->window);
+
+        if (vc->type == GD_VC_GFX &&
+            qemu_console_is_graphic(vc->gfx.dcl.con)) {
+            GtkAccelGroup *ag = gtk_accel_group_new();
+            gtk_window_add_accel_group(GTK_WINDOW(vc->window), ag);
+
+            GClosure *cb = g_cclosure_new_swap(G_CALLBACK(gd_win_grab),
+                                               vc, NULL);
+            gtk_accel_group_connect(ag, GDK_KEY_g, HOTKEY_MODIFIERS, 0, cb);
+        }
+
+        gd_update_geometry_hints(vc);
+        gd_update_caption(s);
+    }
+}
+
+void gtk_display_init(DisplayState *ds, bool full_screen, bool grab_on_hover,
+                      bool detach_display, bool zoom_to_fit, bool no_grab)
 {
     GtkDisplayState *s = g_malloc0(sizeof(*s));
     char *filename;
     GdkDisplay *window_display;
 
+    s->no_grab = no_grab;
+
     if (!gtkinit) {
         fprintf(stderr, "gtk initialization failed\n");
         exit(1);
@@ -2114,6 +2158,24 @@ void gtk_display_init(DisplayState *ds, bool full_screen, bool grab_on_hover)
     if (grab_on_hover) {
         gtk_menu_item_activate(GTK_MENU_ITEM(s->grab_on_hover_item));
     }
+    if (detach_display) {
+        /* Find the first graphic console and detach it */
+        VirtualConsole *vc = gd_vc_find_current(s);
+        if (vc) {
+            gd_detach_vc(s, vc);
+            /* Hide the main window */
+            gtk_widget_hide(s->window);
+        }
+    }
+    if (zoom_to_fit) {
+        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->zoom_fit_item),
+                                       TRUE);
+    }
+    if (no_grab) {
+        /* Disable grab menu items when grab is disabled */
+        gtk_widget_set_sensitive(s->grab_item, FALSE);
+        gtk_widget_set_sensitive(s->grab_on_hover_item, FALSE);
+    }
 
     gd_set_keycode_type(s);
 }
diff --git a/vl.c b/vl.c
index 4211ff1ff..d4237dedb 100644
--- a/vl.c
+++ b/vl.c
@@ -153,6 +153,9 @@ static int no_frame = 0;
 int no_quit = 0;
 #ifdef CONFIG_GTK
 static bool grab_on_hover;
+static bool detach_display;
+static bool zoom_to_fit;
+static bool no_grab;
 #endif
 CharDriverState *serial_hds[MAX_SERIAL_PORTS];
 CharDriverState *parallel_hds[MAX_PARALLEL_PORTS];
@@ -2194,6 +2197,33 @@ static DisplayType select_display(const char *p)
                 } else {
                     goto invalid_gtk_args;
                 }
+            } else if (strstart(opts, ",detach=", &nextopt)) {
+                opts = nextopt;
+                if (strstart(opts, "on", &nextopt)) {
+                    detach_display = true;
+                } else if (strstart(opts, "off", &nextopt)) {
+                    detach_display = false;
+                } else {
+                    goto invalid_gtk_args;
+                }
+            } else if (strstart(opts, ",zoom_to_fit=", &nextopt)) {
+                opts = nextopt;
+                if (strstart(opts, "on", &nextopt)) {
+                    zoom_to_fit = true;
+                } else if (strstart(opts, "off", &nextopt)) {
+                    zoom_to_fit = false;
+                } else {
+                    goto invalid_gtk_args;
+                }
+            } else if (strstart(opts, ",grab=", &nextopt)) {
+                opts = nextopt;
+                if (strstart(opts, "on", &nextopt)) {
+                    no_grab = false;
+                } else if (strstart(opts, "off", &nextopt)) {
+                    no_grab = true;
+                } else {
+                    goto invalid_gtk_args;
+                }
             } else {
             invalid_gtk_args:
                 error_report("invalid GTK option string");
@@ -4597,7 +4627,8 @@ int main(int argc, char **argv, char **envp)
 #endif
 #if defined(CONFIG_GTK)
     case DT_GTK:
-        gtk_display_init(ds, full_screen, grab_on_hover);
+        gtk_display_init(ds, full_screen, grab_on_hover, detach_display,
+                         zoom_to_fit, no_grab);
         break;
 #endif
     default:
